---
layout: post
title:  "[ES6] Proxy"
date:   2017-03-06 13:47:00 +0900
---

# Proxy

```javascript
let target = { foo: 1 };
let handler = {
    get: function(target, property, receiver) {
        return 'intercepted';
    }
};
let proxy = new Proxy(target, handler);

proxy.foo
```

 * Proxy는 디자인패턴에 나오는 프록시패턴을 시스템적으로 구현해놓은 구상체.
 * 프록시 호출을 통해 특정 객체의 사용에 관여할 수 있다.
 
## 알아야할 3가지
 * target : Proxy를 적용할 대상객체.
 * handler
  - trap을 여러개 담고 있는 객체로 실제 target에 결합하게 되는 것은 trap이 아니라 handler가 된다.
  - handler 객체의 메소드들을 통해 프락시 객체의 모든 내부 메소드들을 오버라이드할 수 있다.
 * trap : target의 여러 동작을 가로채 게이트웨이 역할을 수행할 함수.
 
## traps
 * handler.getPrototypeOf(target)
    - 지정된 객체의 프로토타입을 반환한다.
    
 * handler.setPrototypeOf(target, prototype)
    - 지정된 객체의 프로토타입을 다른 객체나 null로 바꾼다.
    
 * handler.isExtensible(target)
    - 객체가 확장 가능한지를 결정한다.
    - 객체는 다음의 3가지 함수를 통해 확장 불가능하게 만들 수 있다. 
       - Object.preventExtensions() : prototype에 추가 가능
       - Object.seal() : 쓰기 가능한 데이터 속성값은 변경 가능
       - Object.freeze() : 새로운 속성 추가 X, 속성제거 X, 객체 속성 변경불가 -> 불변의 존재
       
 * handler.preventExtensions(target)
    - 자신의 속성을 추가할 수 없도록 만든다.
    
 * handler.getOwnPropertyDescriptor(target, prop)
    - 속성 설명자를 반환한다.
    
 * handler.defineProperty(target, property, descriptor)
    - 객체의 새로운 속성을 정의하거나 수정한다.
    
 * handler.has(target, prop)
    - in Operator
    
 * handler.get(target, property, receiver)
    - 속성값을 조회한다.
    
 * handler.set(target, property, value, receiver)
    - 속성값을 설정한다.
    
 * handler.deleteProperty(target, property)
    - 속성을 삭제한다.
    
 * handler.ownKeys(target)
    - target 객체 자신이 속성 리스트를 반환한다.
    
 * handler.apply(target, thisArg, argumentsList)
    - 함수 호출 시
    
 * handler.construct(target, argumentsList, newTarget)
    - 생성자 호출 시
 
## Revocable proxy
 * Proxy.revocable(target, handler);
 * 이 함수를 통해 생성되는 프락시는 나중에 폐기시킬 수 있습니다.
 * {proxy: proxy, revoke: invalid function()}
 * 일단 프락시를 폐기시키면, 해당 프락시는 더이상 동작하지 않습니다. -> typeError
```javascript
var revocable = Proxy.revocable({}, {
get: function(target, name) {
 return "[[" + name + "]]";
}
});
var proxy = revocable.proxy;
console.log(proxy.foo); // "[[foo]]"

revocable.revoke();

console.log(proxy.foo); // TypeError is thrown
proxy.foo = 1           // TypeError again
delete proxy.foo;       // still TypeError
typeof proxy            // "object", typeof doesn't trigger any trap
```
 
## Proxy + WeakMap
 * 매번 프로시를 생성하는 것보다 WeakMap에 저장하여 메모리를 절약할 수 있다.
 
## Reflect
 * 가로채기할 수 있는 스크립트 동작에 대한 메서드를 제공하는 Built-in Object
 * 모든 메서드와 프로퍼티는 Static
 * 생성자를 사용할 수 없으며 함수 객체처럼 실행 할 수 없다.
 * proxy handler와 같은 메서드를 제공한다.
 * 내부 built-in method 접근을 위해서 사용한다.
```javascript
let handler = {
 get: function({ foo: 1 }, property, receiver) {
     //... do something ...
     return Reflect.get(target, property, receiver);
 }
};
let proxy = new Proxy(target, handler);

console.log(proxy.foo);
```
 
## Example
proxy.html
 
## Usage
 * Observer
 * Logging